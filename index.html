<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>B·∫£ng Tr·∫Øng Realtime</title>
    <style>
        body {
            overscroll-behavior: none; touch-action: none; font-family: sans-serif;
            display: flex; flex-direction: column; align-items: center;
            margin: 0; padding: 10px; background-color: #f0f0f0; /* Gi·∫£m padding */
        }
        h1 { color: #333; margin-top: 0; margin-bottom: 10px; /* ƒêi·ªÅu ch·ªânh margin */ }

        .toolbar {
            width: 98%; max-width: 800px; margin-bottom: 10px; padding: 8px;
            background-color: #e0e0e0; border-radius: 5px; display: flex;
            flex-wrap: wrap; gap: 8px; justify-content: center; align-items: center;
        }
        .toolbar button { /* N√∫t c√¥ng c·ª• v√† n√∫t m√†u chung */
            padding: 6px 10px; border: 1px solid #999; border-radius: 3px;
            cursor: pointer; background-color: #fff; font-size: 14px;
            min-width: 40px; /* ƒê·∫£m b·∫£o n√∫t kh√¥ng qu√° nh·ªè */
            height: 30px; /* Chi·ªÅu cao c·ªë ƒë·ªãnh */
            box-sizing: border-box; /* T√≠nh c·∫£ padding/border v√†o width/height */
        }
        .toolbar button.active { /* N√∫t c√¥ng c·ª• active */
            background-color: #a0a0a0; font-weight: bold; border-color: #555;
        }
        .toolbar button:disabled { cursor: not-allowed; opacity: 0.6; }

        /* ƒê·ªãnh d·∫°ng ri√™ng cho n√∫t m√†u */
        .color-btn {
            width: 28px; /* K√≠ch th∆∞·ªõc nh·ªè h∆°n */
            height: 28px;
            min-width: 28px;
            padding: 0; /* B·ªè padding */
            border-radius: 50%; /* Bo tr√≤n */
            border: 2px solid #fff; /* Vi·ªÅn tr·∫Øng ƒë·ªÉ n·ªïi b·∫≠t */
            box-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            vertical-align: middle; /* CƒÉn gi·ªØa v·ªõi c√°c n√∫t kh√°c */
        }
        .color-btn.active-color { /* N√∫t m√†u ƒëang ƒë∆∞·ª£c ch·ªçn */
            border-color: #000000; /* Vi·ªÅn ƒëen ƒë·∫≠m */
            transform: scale(1.1); /* Ph√≥ng to nh·∫π */
            box-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .toolbar .separator { /* ƒê∆∞·ªùng k·∫ª ph√¢n c√°ch (t√πy ch·ªçn) */
             border-left: 1px solid #bbb;
             height: 25px;
             margin: 0 5px;
         }

        #whiteboard-container {
            border: 2px solid #000; box-shadow: 3px 3px 5px rgba(0,0,0,0.2);
            line-height: 0; touch-action: none;
            width: 98%; /* Cho container linh ho·∫°t */
             max-width: 802px; /* H∆°i l·ªõn h∆°n canvas ƒë·ªÉ ch·ª©a border */
        }

        #drawing-canvas {
             display: block; background-color: #ffffff; touch-action: none;
             width: 100%; /* Canvas chi·∫øm ƒë·∫ßy container */
             height: auto; /* Chi·ªÅu cao t·ª± ƒë·ªông theo t·ªâ l·ªá width/height ƒë·∫∑t b·∫±ng JS */
             /* B·ªè cursor v√¨ kh√¥ng hi·ªÉn th·ªã tr√™n mobile */
        }

    </style>
    </head>
<body>

    <h1>B·∫£ng Tr·∫Øng Realtime</h1>

    <div class="toolbar">
        <button id="pen-tool-btn" class="active" title="B√∫t v·∫Ω">‚úèÔ∏è</button> <button id="eraser-tool-btn" title="T·∫©y">üßº</button> <button id="text-tool-btn" title="Ch·ªØ T">T</button>

        <div class="separator"></div> <button class="color-btn" data-color="#000000" style="background-color: #000000;" title="ƒêen"></button>
        <button class="color-btn" data-color="#FF0000" style="background-color: #FF0000;" title="ƒê·ªè"></button>
        <button class="color-btn" data-color="#0000FF" style="background-color: #0000FF;" title="Xanh d∆∞∆°ng"></button>
        <button class="color-btn" data-color="#008000" style="background-color: #008000;" title="Xanh l√°"></button>
        <button class="color-btn" data-color="#FFFF00" style="background-color: #FFFF00;" title="V√†ng"></button>
        <button class="color-btn" data-color="#FFA500" style="background-color: #FFA500;" title="Cam"></button>

        <div class="separator"></div>

        <button id="undo-btn" disabled title="Ho√†n t√°c">‚Ü©Ô∏è</button>
        <button id="clear-btn" title="X√≥a h·∫øt">üóëÔ∏è</button>
    </div>

    <div id="whiteboard-container">
        <canvas id="drawing-canvas"></canvas>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        window.addEventListener('load', () => {
            // --- Tham chi·∫øu v√† Context ---
            const canvas = document.getElementById('drawing-canvas');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const container = document.getElementById('whiteboard-container');
            const penBtn = document.getElementById('pen-tool-btn');
            const eraserBtn = document.getElementById('eraser-tool-btn');
            const textBtn = document.getElementById('text-tool-btn');
            const undoBtn = document.getElementById('undo-btn');
            const clearBtn = document.getElementById('clear-btn');
            const colorBtns = document.querySelectorAll('.color-btn'); // L·∫•y t·∫•t c·∫£ n√∫t m√†u

            // --- K·∫øt n·ªëi Socket.IO ---
            const socket = io();
            socket.on('connect', () => console.log('‚úÖ ƒê√£ k·∫øt n·ªëi t·ªõi Server Socket.IO:', socket.id));
            socket.on('disconnect', () => console.log('‚ùå ƒê√£ ng·∫Øt k·∫øt n·ªëi kh·ªèi Server Socket.IO'));

            // --- C√†i ƒë·∫∑t k√≠ch th∆∞·ªõc Canvas ---
             function resizeCanvas() {
                const containerWidth = container.clientWidth; // L·∫•y chi·ªÅu r·ªông th·ª±c t·∫ø c·ªßa container
                // Gi·ªØ t·ª∑ l·ªá 4:3 (ho·∫∑c t·ª∑ l·ªá kh√°c b·∫°n mu·ªën)
                const aspectRatio = 4 / 3;
                canvas.width = containerWidth;
                canvas.height = containerWidth / aspectRatio;
                // N·∫øu mu·ªën gi·ªõi h·∫°n chi·ªÅu cao t·ªëi ƒëa (v√≠ d·ª•: 80% chi·ªÅu cao c·ª≠a s·ªï)
                // canvas.height = Math.min(containerWidth / aspectRatio, window.innerHeight * 0.7);
                console.log(`Resized canvas to: ${canvas.width}x${canvas.height}`);
                 // V·∫Ω l·∫°i to√†n b·ªô history sau khi resize (ph·ª©c t·∫°p, t·∫°m b·ªè qua, ch·ªâ l∆∞u tr·∫°ng th√°i cu·ªëi)
                 redrawLastState(); // V·∫Ω l·∫°i tr·∫°ng th√°i cu·ªëi c√πng sau khi resize
             }


             // --- Bi·∫øn tr·∫°ng th√°i ---
            let currentMode = 'draw';
            let isDrawing = false;
            let lastX = 0;
            let lastY = 0;
            let currentColor = '#000000'; // M√†u m·∫∑c ƒë·ªãnh ban ƒë·∫ßu
            let currentLineWidth = 5; // C√≥ th·ªÉ th√™m ch·ª©c nƒÉng ch·ªânh sau
            let currentFont = '16px sans-serif';
            const eraserColor = '#ffffff';
            let activeColorButton = null; // L∆∞u n√∫t m√†u ƒëang active

            // --- Undo/History (Local) ---
            let historyStack = [];
            const MAX_HISTORY_STATES = 20;
            function saveHistoryState() { /* ... gi·ªØ nguy√™n ... */ const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height); historyStack.push(imageData); if (historyStack.length > MAX_HISTORY_STATES) { historyStack.shift(); } updateUndoButtonState(); }
            function undoLastAction() { /* ... gi·ªØ nguy√™n ... */ if (historyStack.length <= 1) return; historyStack.pop(); redrawLastState(); updateUndoButtonState(); console.log("Ho√†n t√°c (local)"); }
            function updateUndoButtonState() { undoBtn.disabled = (historyStack.length <= 1); }
             function redrawLastState() { // H√†m v·∫Ω l·∫°i tr·∫°ng th√°i cu·ªëi t·ª´ history
                 if (historyStack.length > 0) {
                     const lastState = historyStack[historyStack.length - 1];
                     // ƒê·∫£m b·∫£o k√≠ch th∆∞·ªõc canvas ph√π h·ª£p tr∆∞·ªõc khi v·∫Ω l·∫°i
                     // (Trong tr∆∞·ªùng h·ª£p resize, k√≠ch th∆∞·ªõc c√≥ th·ªÉ ƒë√£ thay ƒë·ªïi)
                     // T·∫°m th·ªùi gi·∫£ ƒë·ªãnh k√≠ch th∆∞·ªõc kh√¥ng ƒë·ªïi khi ch·ªâ v·∫Ω l·∫°i
                      ctx.putImageData(lastState, 0, 0);
                 } else {
                      ctx.clearRect(0, 0, canvas.width, canvas.height); // N·∫øu kh√¥ng c√≥ history th√¨ x√≥a
                 }
             }


             // --- L·∫•y t·ªça ƒë·ªô chu·∫©n h√≥a ---
             function getCoordinates(e) { /* ... gi·ªØ nguy√™n ... */
                  let x, y; const rect = canvas.getBoundingClientRect(); if (e.touches && e.touches.length > 0) { x = e.touches[0].clientX - rect.left; y = e.touches[0].clientY - rect.top; } else if (e.changedTouches && e.changedTouches.length > 0) { x = e.changedTouches[0].clientX - rect.left; y = e.changedTouches[0].clientY - rect.top; } else { x = e.clientX - rect.left; y = e.clientY - rect.top; } return { x, y };
             }

            // --- H√†m v·∫Ω/t·∫©y/ch·ªØ t·ª´ d·ªØ li·ªáu ---
            function drawSegmentFromData(data) { /* ... gi·ªØ nguy√™n ... */ const { mode, x1, y1, x2, y2, color, width } = data; const tempStrokeStyle = ctx.strokeStyle; const tempLineWidth = ctx.lineWidth; const tempLineCap = ctx.lineCap; const tempLineJoin = ctx.lineJoin; ctx.strokeStyle = color; ctx.lineWidth = width; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke(); ctx.strokeStyle = tempStrokeStyle; ctx.lineWidth = tempLineWidth; ctx.lineCap = tempLineCap; ctx.lineJoin = tempLineJoin;}
            function drawTextFromData(data){ /* ... gi·ªØ nguy√™n ... */ const { text, x, y, color, font } = data; const tempFillStyle = ctx.fillStyle; const tempFont = ctx.font; const tempTextAlign = ctx.textAlign; const tempTextBaseline = ctx.textBaseline; ctx.fillStyle = color; ctx.font = font; ctx.textAlign = 'left'; ctx.textBaseline = 'top'; ctx.fillText(text, x, y); ctx.fillStyle = tempFillStyle; ctx.font = tempFont; ctx.textAlign = tempTextAlign; ctx.textBaseline = tempTextBaseline;}
            function clearCanvasLocal() { /* ... gi·ªØ nguy√™n ... */ ctx.clearRect(0, 0, canvas.width, canvas.height); historyStack = []; saveHistoryState(); updateUndoButtonState();}
            function clearCanvasAndEmit() { /* ... gi·ªØ nguy√™n ... */ if (confirm("B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a to√†n b·ªô n·ªôi dung b·∫£ng tr·∫Øng?")) { clearCanvasLocal(); socket.emit('clear_action'); console.log("ƒê√£ x√≥a h·∫øt v√† g·ª≠i t√≠n hi·ªáu."); }}

            // --- C·∫≠p nh·∫≠t giao di·ªán ng∆∞·ªùi d√πng (Tool & Color Buttons) ---
            function updateToolUI() {
                // C·∫≠p nh·∫≠t n√∫t c√¥ng c·ª• ch√≠nh
                penBtn.classList.remove('active');
                eraserBtn.classList.remove('active');
                textBtn.classList.remove('active');
                if (currentMode === 'draw') penBtn.classList.add('active');
                else if (currentMode === 'eraser') eraserBtn.classList.add('active');
                else if (currentMode === 'text') textBtn.classList.add('active');

                // C·∫≠p nh·∫≠t n√∫t m√†u
                colorBtns.forEach(btn => btn.classList.remove('active-color'));
                if (activeColorButton) {
                    activeColorButton.classList.add('active-color');
                }
                 // C·∫≠p nh·∫≠t cursor (ch·ªâ hi·ªáu qu·∫£ tr√™n desktop)
                 // if (currentMode === 'text') canvas.style.cursor = 'text';
                 // else canvas.style.cursor = 'crosshair'; // M·∫∑c ƒë·ªãnh ho·∫∑c t·∫©y
            }

            // --- G·∫Øn s·ª± ki·ªán n√∫t c√¥ng c·ª• ---
            penBtn.addEventListener('click', () => { currentMode = 'draw'; updateToolUI(); });
            eraserBtn.addEventListener('click', () => { currentMode = 'eraser'; updateToolUI(); });
            textBtn.addEventListener('click', () => { currentMode = 'text'; updateToolUI(); });
            undoBtn.addEventListener('click', undoLastAction);
            clearBtn.addEventListener('click', clearCanvasAndEmit);

            // --- G·∫Øn s·ª± ki·ªán n√∫t M√ÄU ---
             colorBtns.forEach(btn => {
                 btn.addEventListener('click', () => {
                     currentColor = btn.dataset.color; // L·∫•y m√†u t·ª´ data-attribute
                     activeColorButton = btn; // ƒê·∫∑t n√∫t n√†y l√† active
                     console.log("ƒê√£ ch·ªçn m√†u:", currentColor);

                     // T·ª± ƒë·ªông chuy·ªÉn sang ch·∫ø ƒë·ªô v·∫Ω khi ch·ªçn m√†u
                     currentMode = 'draw';
                     updateToolUI(); // C·∫≠p nh·∫≠t to√†n b·ªô UI
                 });
             });

            // --- X·ª≠ l√Ω t∆∞∆°ng t√°c (Start, Move, End - gi·ªØ nguy√™n) ---
            function handleInteractionStart(e) { if (e.type === 'touchstart') e.preventDefault(); const coords = getCoordinates(e); if (currentMode === 'draw' || currentMode === 'eraser') { isDrawing = true; [lastX, lastY] = [coords.x, coords.y]; drawDot(lastX, lastY); } else if (currentMode === 'text') { placeText(coords); }}
            function drawDot(x, y) { ctx.beginPath(); ctx.fillStyle = (currentMode === 'eraser') ? eraserColor : currentColor; ctx.arc(x, y, currentLineWidth / 2, 0, Math.PI * 2); ctx.fill(); }
            function handleInteractionMove(e) { if (e.type === 'touchmove') e.preventDefault(); if (!isDrawing) return; const coords = getCoordinates(e); const x2 = coords.x; const y2 = coords.y; const drawData = { mode: currentMode, x1: lastX, y1: lastY, x2: x2, y2: y2, color: (currentMode === 'eraser') ? eraserColor : currentColor, width: currentLineWidth }; drawSegmentFromData(drawData); socket.emit('draw_action', drawData); [lastX, lastY] = [x2, y2];}
            function handleInteractionEnd(e) { if (isDrawing) { isDrawing = false; saveHistoryState(); }}
            function placeText(coords) { const text = prompt("Nh·∫≠p vƒÉn b·∫£n:"); if (text) { const textData = { text: text, x: coords.x, y: coords.y, color: currentColor, font: currentFont }; drawTextFromData(textData); saveHistoryState(); socket.emit('text_action', textData); console.log(`ƒê√£ th√™m ch·ªØ v√† g·ª≠i: "${text}"`); } else { console.log("ƒê√£ h·ªßy th√™m ch·ªØ."); }}

            // --- G·∫Øn c√°c Event Listeners (gi·ªØ nguy√™n) ---
            canvas.addEventListener('mousedown', handleInteractionStart); canvas.addEventListener('mousemove', handleInteractionMove); canvas.addEventListener('mouseup', handleInteractionEnd); canvas.addEventListener('mouseout', handleInteractionEnd);
            canvas.addEventListener('touchstart', handleInteractionStart, { passive: false }); canvas.addEventListener('touchmove', handleInteractionMove, { passive: false }); canvas.addEventListener('touchend', handleInteractionEnd); canvas.addEventListener('touchcancel', handleInteractionEnd);

             // --- L·∫Øng nghe s·ª± ki·ªán t·ª´ Server (gi·ªØ nguy√™n) ---
             socket.on('draw_action', (data) => { console.log('<< Nh·∫≠n draw_action'); drawSegmentFromData(data); });
             socket.on('text_action', (data) => { console.log('<< Nh·∫≠n text_action'); drawTextFromData(data); });
             socket.on('clear_action', () => { console.log('<< Nh·∫≠n clear_action'); clearCanvasLocal(); });

            // --- Kh·ªüi t·∫°o ---
             resizeCanvas(); // ƒê·∫∑t k√≠ch th∆∞·ªõc canvas ban ƒë·∫ßu
             window.addEventListener('resize', resizeCanvas); // Thay ƒë·ªïi k√≠ch th∆∞·ªõc canvas khi c·ª≠a s·ªï thay ƒë·ªïi

             // ƒê·∫∑t n√∫t m√†u ƒëen l√†m active ban ƒë·∫ßu
             activeColorButton = document.querySelector('.color-btn[data-color="#000000"]');
             updateToolUI(); // C·∫≠p nh·∫≠t UI ban ƒë·∫ßu
             saveHistoryState(); // L∆∞u tr·∫°ng th√°i tr·ªëng ban ƒë·∫ßu
             console.log("B·∫£ng v·∫Ω Realtime Client (v·ªõi Touch & Colors) ƒë√£ s·∫µn s√†ng!");
        });
    </script>
    </body>
</html>
